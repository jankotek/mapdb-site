<HTML>
<HEAD>
<title>Volume - mapdb</title>
<link rel="stylesheet" href="../../../style.css">
</HEAD>
<BODY>
<a href="../../index.html">mapdb</a>&nbsp;/&nbsp;<a href="../index.html">org.mapdb.volume</a>&nbsp;/&nbsp;<a href=".">Volume</a><br/>
<br/>
<h1>Volume</h1>
<code><span class="keyword">abstract</span> <span class="keyword">class </span><span class="identifier">Volume</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/6/docs/api/java/io/Closeable.html"><span class="identifier">Closeable</span></a></code><br/>
<p><p> MapDB abstraction over raw storage (file, disk partition, memory etc...). </p>
<p> Implementations needs to be thread safe (especially 'ensureAvailable') operation. However updates do not have to be atomic, it is clients responsibility to ensure two threads are not writing/reading into the same location. </p>
 </p>
<strong>Author</strong><br/>
Jan Kotek<br/>
<br/>
<br/>
<h3>Types</h3>
<table>
<tbody>
<tr>
<td>
<a href="-memory-vol/index.html">MemoryVol</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">MemoryVol</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../-byte-buffer-vol/index.html"><span class="identifier">ByteBufferVol</span></a></code></td>
</tr>
<tr>
<td>
<a href="-memory-vol-single/index.html">MemoryVolSingle</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">MemoryVolSingle</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../-byte-buffer-vol-single/index.html"><span class="identifier">ByteBufferVolSingle</span></a></code></td>
</tr>
</tbody>
</table>
<h3>Constructors</h3>
<table>
<tbody>
<tr>
<td>
<a href="-init-.html">&lt;init&gt;</a></td>
<td>
<code><span class="identifier">Volume</span><span class="symbol">(</span><span class="symbol">)</span></code></td>
</tr>
</tbody>
</table>
<h3>Properties</h3>
<table>
<tbody>
<tr>
<td>
<a href="-u-n-s-a-f-e_-v-o-l_-f-a-c-t-o-r-y.html">UNSAFE_VOL_FACTORY</a></td>
<td>
<code><span class="keyword">static</span> <span class="keyword">val </span><span class="identifier">UNSAFE_VOL_FACTORY</span><span class="symbol">: </span><a href="../-volume-factory/index.html"><span class="identifier">VolumeFactory</span></a></code><p>If <code>sun.misc.Unsafe</code> is available it will use Volume based on Unsafe. If Unsafe is not available for some reason (Android), use DirectByteBuffer instead. </p>
</td>
</tr>
</tbody>
</table>
<h3>Functions</h3>
<table>
<tbody>
<tr>
<td>
<a href="assert-zeroes.html">assertZeroes</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">assertZeroes</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$assertZeroes(kotlin.Long, kotlin.Long)/startOffset">startOffset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$assertZeroes(kotlin.Long, kotlin.Long)/endOffset">endOffset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code><p>Check that all bytes between given offsets are zero. This might cross 1MB boundaries </p>
</td>
</tr>
<tr>
<td>
<a href="clear.html">clear</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">clear</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$clear(kotlin.Long, kotlin.Long)/startOffset">startOffset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$clear(kotlin.Long, kotlin.Long)/endOffset">endOffset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code><p>Set all bytes between <code>startOffset</code> and <code>endOffset</code> to zero. Area between offsets must be ready for write once clear finishes. </p>
</td>
</tr>
<tr>
<td>
<a href="clear-overlap.html">clearOverlap</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">clearOverlap</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$clearOverlap(kotlin.Long, kotlin.Long)/startOffset">startOffset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$clearOverlap(kotlin.Long, kotlin.Long)/endOffset">endOffset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code></td>
</tr>
<tr>
<td>
<a href="close.html">close</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">close</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code></td>
</tr>
<tr>
<td>
<a href="copy-entire-volume-to.html">copyEntireVolumeTo</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">copyEntireVolumeTo</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$copyEntireVolumeTo(org.mapdb.volume.Volume)/to">to</span><span class="symbol">:</span>&nbsp;<span class="identifier">Volume</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code><p>Copy content of this volume to another. Target volume might grow, but is never shrank. Target is also not synced </p>
</td>
</tr>
<tr>
<td>
<a href="delete-file.html">deleteFile</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">deleteFile</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code></td>
</tr>
<tr>
<td>
<a href="ensure-available.html">ensureAvailable</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">ensureAvailable</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$ensureAvailable(kotlin.Long)/offset">offset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code><p>Check space allocated by Volume is bigger or equal to given offset. So it is safe to write into smaller offsets. </p>
</td>
</tr>
<tr>
<td>
<a href="file-load.html">fileLoad</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">fileLoad</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Boolean</span></code><p><p> If underlying storage is memory-mapped-file, this method will try to load and precache all file data into disk cache. Most likely it will call <code><a href="#">MappedByteBuffer#load()</a></code>, but could also read content of entire file etc This method will not pin data into memory, they might be removed at any time. </p>
 </p>
</td>
</tr>
<tr>
<td>
<a href="get-byte.html">getByte</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">getByte</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$getByte(kotlin.Long)/offset">offset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Byte</span></code></td>
</tr>
<tr>
<td>
<a href="get-data.html">getData</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">getData</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$getData(kotlin.Long, kotlin.ByteArray, kotlin.Int, kotlin.Int)/offset">offset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$getData(kotlin.Long, kotlin.ByteArray, kotlin.Int, kotlin.Int)/bytes">bytes</span><span class="symbol">:</span>&nbsp;<span class="identifier">ByteArray</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$getData(kotlin.Long, kotlin.ByteArray, kotlin.Int, kotlin.Int)/bytesPos">bytesPos</span><span class="symbol">:</span>&nbsp;<span class="identifier">Int</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$getData(kotlin.Long, kotlin.ByteArray, kotlin.Int, kotlin.Int)/size">size</span><span class="symbol">:</span>&nbsp;<span class="identifier">Int</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code></td>
</tr>
<tr>
<td>
<a href="get-data-input.html">getDataInput</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">getDataInput</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$getDataInput(kotlin.Long, kotlin.Int)/offset">offset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$getDataInput(kotlin.Long, kotlin.Int)/size">size</span><span class="symbol">:</span>&nbsp;<span class="identifier">Int</span><span class="symbol">)</span><span class="symbol">: </span><a href="../../org.mapdb/-data-input2/index.html"><span class="identifier">DataInput2</span></a></code></td>
</tr>
<tr>
<td>
<a href="get-data-input-overlap.html">getDataInputOverlap</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">getDataInputOverlap</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$getDataInputOverlap(kotlin.Long, kotlin.Int)/offset">offset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$getDataInputOverlap(kotlin.Long, kotlin.Int)/size">size</span><span class="symbol">:</span>&nbsp;<span class="identifier">Int</span><span class="symbol">)</span><span class="symbol">: </span><a href="../../org.mapdb/-data-input2/index.html"><span class="identifier">DataInput2</span></a></code></td>
</tr>
<tr>
<td>
<a href="get-file.html">getFile</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">getFile</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/6/docs/api/java/io/File.html"><span class="identifier">File</span></a></code><p>returns underlying file if it exists </p>
</td>
</tr>
<tr>
<td>
<a href="get-file-locked.html">getFileLocked</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">getFileLocked</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Boolean</span></code><p>return true if this Volume holds exclusive lock over its file </p>
</td>
</tr>
<tr>
<td>
<a href="get-int.html">getInt</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">getInt</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$getInt(kotlin.Long)/offset">offset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Int</span></code></td>
</tr>
<tr>
<td>
<a href="get-long.html">getLong</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">getLong</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$getLong(kotlin.Long)/offset">offset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Long</span></code></td>
</tr>
<tr>
<td>
<a href="get-packed-long.html">getPackedLong</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">getPackedLong</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$getPackedLong(kotlin.Long)/position">position</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Long</span></code><p>Unpack long value from the Volume. Highest 4 bits reused to indicate number of bytes read from Volume. One can use <code>result &amp; DBUtil.PACK_LONG_RESULT_MASK</code> to remove size; </p>
</td>
</tr>
<tr>
<td>
<a href="get-six-long.html">getSixLong</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">getSixLong</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$getSixLong(kotlin.Long)/pos">pos</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Long</span></code></td>
</tr>
<tr>
<td>
<a href="get-unsigned-byte.html">getUnsignedByte</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">getUnsignedByte</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$getUnsignedByte(kotlin.Long)/offset">offset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Int</span></code></td>
</tr>
<tr>
<td>
<a href="get-unsigned-short.html">getUnsignedShort</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">getUnsignedShort</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$getUnsignedShort(kotlin.Long)/offset">offset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Int</span></code></td>
</tr>
<tr>
<td>
<a href="hash.html">hash</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">hash</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$hash(kotlin.Long, kotlin.Long, kotlin.Long)/off">off</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$hash(kotlin.Long, kotlin.Long, kotlin.Long)/len">len</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$hash(kotlin.Long, kotlin.Long, kotlin.Long)/seed">seed</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Long</span></code><p><p> Calculates XXHash64 from this Volume content. </p>
<p> This code comes from <a href="#">LZ4-Java</a> created by Adrien Grand. </p>
 </p>
</td>
</tr>
<tr>
<td>
<a href="is-closed.html">isClosed</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">isClosed</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Boolean</span></code></td>
</tr>
<tr>
<td>
<a href="is-sliced.html">isSliced</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">isSliced</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Boolean</span></code></td>
</tr>
<tr>
<td>
<a href="length.html">length</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">length</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Long</span></code></td>
</tr>
<tr>
<td>
<a href="put-byte.html">putByte</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">putByte</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$putByte(kotlin.Long, kotlin.Byte)/offset">offset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$putByte(kotlin.Long, kotlin.Byte)/value">value</span><span class="symbol">:</span>&nbsp;<span class="identifier">Byte</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code></td>
</tr>
<tr>
<td>
<a href="put-data.html">putData</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">putData</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$putData(kotlin.Long, kotlin.ByteArray, kotlin.Int, kotlin.Int)/offset">offset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$putData(kotlin.Long, kotlin.ByteArray, kotlin.Int, kotlin.Int)/src">src</span><span class="symbol">:</span>&nbsp;<span class="identifier">ByteArray</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$putData(kotlin.Long, kotlin.ByteArray, kotlin.Int, kotlin.Int)/srcPos">srcPos</span><span class="symbol">:</span>&nbsp;<span class="identifier">Int</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$putData(kotlin.Long, kotlin.ByteArray, kotlin.Int, kotlin.Int)/srcSize">srcSize</span><span class="symbol">:</span>&nbsp;<span class="identifier">Int</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code><br/>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">putData</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$putData(kotlin.Long, java.nio.ByteBuffer)/offset">offset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$putData(kotlin.Long, java.nio.ByteBuffer)/buf">buf</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/6/docs/api/java/nio/ByteBuffer.html"><span class="identifier">ByteBuffer</span></a><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code></td>
</tr>
<tr>
<td>
<a href="put-data-overlap.html">putDataOverlap</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">putDataOverlap</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$putDataOverlap(kotlin.Long, kotlin.ByteArray, kotlin.Int, kotlin.Int)/offset">offset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$putDataOverlap(kotlin.Long, kotlin.ByteArray, kotlin.Int, kotlin.Int)/src">src</span><span class="symbol">:</span>&nbsp;<span class="identifier">ByteArray</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$putDataOverlap(kotlin.Long, kotlin.ByteArray, kotlin.Int, kotlin.Int)/srcPos">srcPos</span><span class="symbol">:</span>&nbsp;<span class="identifier">Int</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$putDataOverlap(kotlin.Long, kotlin.ByteArray, kotlin.Int, kotlin.Int)/srcSize">srcSize</span><span class="symbol">:</span>&nbsp;<span class="identifier">Int</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code></td>
</tr>
<tr>
<td>
<a href="put-int.html">putInt</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">putInt</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$putInt(kotlin.Long, kotlin.Int)/offset">offset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$putInt(kotlin.Long, kotlin.Int)/value">value</span><span class="symbol">:</span>&nbsp;<span class="identifier">Int</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code></td>
</tr>
<tr>
<td>
<a href="put-long.html">putLong</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">putLong</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$putLong(kotlin.Long, kotlin.Long)/offset">offset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$putLong(kotlin.Long, kotlin.Long)/value">value</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code></td>
</tr>
<tr>
<td>
<a href="put-packed-long.html">putPackedLong</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">putPackedLong</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$putPackedLong(kotlin.Long, kotlin.Long)/pos">pos</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$putPackedLong(kotlin.Long, kotlin.Long)/value">value</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Int</span></code><p>Put packed long at given position. </p>
</td>
</tr>
<tr>
<td>
<a href="put-six-long.html">putSixLong</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">putSixLong</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$putSixLong(kotlin.Long, kotlin.Long)/pos">pos</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$putSixLong(kotlin.Long, kotlin.Long)/value">value</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code></td>
</tr>
<tr>
<td>
<a href="put-unsigned-byte.html">putUnsignedByte</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">putUnsignedByte</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$putUnsignedByte(kotlin.Long, kotlin.Int)/offset">offset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$putUnsignedByte(kotlin.Long, kotlin.Int)/b">b</span><span class="symbol">:</span>&nbsp;<span class="identifier">Int</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code></td>
</tr>
<tr>
<td>
<a href="put-unsigned-short.html">putUnsignedShort</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">putUnsignedShort</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$putUnsignedShort(kotlin.Long, kotlin.Int)/offset">offset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$putUnsignedShort(kotlin.Long, kotlin.Int)/value">value</span><span class="symbol">:</span>&nbsp;<span class="identifier">Int</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code></td>
</tr>
<tr>
<td>
<a href="slice-size.html">sliceSize</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">sliceSize</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Int</span></code><p></p>
</td>
</tr>
<tr>
<td>
<a href="sync.html">sync</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">sync</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code></td>
</tr>
<tr>
<td>
<a href="transfer-into.html">transferInto</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="identifier">transferInto</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$transferInto(kotlin.Long, org.mapdb.volume.Volume, kotlin.Long, kotlin.Long)/inputOffset">inputOffset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$transferInto(kotlin.Long, org.mapdb.volume.Volume, kotlin.Long, kotlin.Long)/target">target</span><span class="symbol">:</span>&nbsp;<span class="identifier">Volume</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$transferInto(kotlin.Long, org.mapdb.volume.Volume, kotlin.Long, kotlin.Long)/targetOffset">targetOffset</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$transferInto(kotlin.Long, org.mapdb.volume.Volume, kotlin.Long, kotlin.Long)/size">size</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code><p>Transfers data from this Volume into target volume. If its possible, the implementation should override this method to enable direct memory transfer. Caller must respect slice boundaries. ie it is not possible to transfer data which cross slice boundaries. </p>
</td>
</tr>
<tr>
<td>
<a href="truncate.html">truncate</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">truncate</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$truncate(kotlin.Long)/size">size</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code></td>
</tr>
<tr>
<td>
<a href="volume-transfer.html">volumeTransfer</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">static</span> <span class="keyword">fun </span><span class="identifier">volumeTransfer</span><span class="symbol">(</span><span class="identifier" id="org.mapdb.volume.Volume$volumeTransfer(kotlin.Long, org.mapdb.volume.Volume, org.mapdb.volume.Volume)/size">size</span><span class="symbol">:</span>&nbsp;<span class="identifier">Long</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$volumeTransfer(kotlin.Long, org.mapdb.volume.Volume, org.mapdb.volume.Volume)/from">from</span><span class="symbol">:</span>&nbsp;<span class="identifier">Volume</span><span class="symbol">, </span><span class="identifier" id="org.mapdb.volume.Volume$volumeTransfer(kotlin.Long, org.mapdb.volume.Volume, org.mapdb.volume.Volume)/to">to</span><span class="symbol">:</span>&nbsp;<span class="identifier">Volume</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code><p>transfer data from one volume to second. Second volume will be expanded if needed</p>
</td>
</tr>
</tbody>
</table>
<h3>Inheritors</h3>
<table>
<tbody>
<tr>
<td>
<a href="../-byte-array-vol/index.html">ByteArrayVol</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">ByteArrayVol</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">Volume</span></code><p>Created by jan on 2/29/16. </p>
</td>
</tr>
<tr>
<td>
<a href="../-byte-buffer-vol/index.html">ByteBufferVol</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">class </span><span class="identifier">ByteBufferVol</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">Volume</span></code><p>Abstract Volume over bunch of ByteBuffers It leaves ByteBufferVol details (allocation, disposal) on subclasses. Most methods are final for better performance (JIT compiler can inline those). </p>
</td>
</tr>
<tr>
<td>
<a href="../-byte-buffer-vol-single/index.html">ByteBufferVolSingle</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">class </span><span class="identifier">ByteBufferVolSingle</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">Volume</span></code><p>Abstract Volume over single ByteBuffer, maximal size is 2GB (32bit limit). It leaves ByteBufferVol details (allocation, disposal) on subclasses. Most methods are final for better performance (JIT compiler can inline those). </p>
</td>
</tr>
<tr>
<td>
<a href="../-file-channel-vol/index.html">FileChannelVol</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">FileChannelVol</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">Volume</span></code><p>Volume which uses FileChannel. Uses global lock and does not use mapped memory. </p>
</td>
</tr>
<tr>
<td>
<a href="../-random-access-file-vol/index.html">RandomAccessFileVol</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">RandomAccessFileVol</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">Volume</span></code><p>Created by jan on 2/29/16. </p>
</td>
</tr>
<tr>
<td>
<a href="../-read-only-volume/index.html">ReadOnlyVolume</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">ReadOnlyVolume</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">Volume</span></code><p>Created by jan on 2/29/16. </p>
</td>
</tr>
<tr>
<td>
<a href="../-single-byte-array-vol/index.html">SingleByteArrayVol</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">SingleByteArrayVol</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">Volume</span></code><p>Volume backed by on-heap byte[] with maximal fixed size 2GB. For thread-safety it can not be grown </p>
</td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
