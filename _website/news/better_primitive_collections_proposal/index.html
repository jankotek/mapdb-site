<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Better primitive collections &mdash; MapDB</title>
    
    <link rel="stylesheet" href="../../_static/sphinx13.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="MapDB" href="../../" />
  
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

<!-- google analytics-->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42074659-1', 'auto');
  ga('send', 'pageview');

</script>

  
  <link rel="alternate" type="application/atom+xml"  href="../../blog/atom.xml" title="MapDB Blog">
  
  
  <style type="text/css">
    ul.ablog-archive {list-style: none; overflow: auto; margin-left: 0px}
    ul.ablog-archive li {float: left; margin-right: 5px; font-size: 80%}
    ul.postlist a {font-style: italic;}
    ul.postlist-style-disc {list-style-type: disc;}
    ul.postlist-style-none {list-style-type: none;}
    ul.postlist-style-circle {list-style-type: circle;}
  </style>

  </head>
  <body role="document">
<div class="pageheader">
  <ul>
    <li><a href="../../">Home</a></li>
    <li><a href="../../doc/getting-started/">Intro</a></li>
    <li><a href="../../doc/">Docs</a></li>
    <li><a href="../../blog/">Blog</a></li>
    <li><a href="https://github.com/jankotek/mapdb">Github</a></li>
  </ul>
  <div>
    <a href="../../">
      <img src="../../_static/logo.png" alt="MapDB" />
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li><a href="../../">Home</a>&nbsp;|</li>
 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Better primitive collections</a><ul>
<li><a class="reference internal" href="#memory-mapped-files">Memory mapped files</a></li>
<li><a class="reference internal" href="#code-generators">Code generators</a></li>
<li><a class="reference internal" href="#byte-versus-8bit-integer">Byte versus 8bit Integer</a></li>
<li><a class="reference internal" href="#bit-support">64bit support</a></li>
<li><a class="reference internal" href="#data-corruption">Data corruption</a></li>
<li><a class="reference internal" href="#object-serialization">Object serialization</a></li>
<li><a class="reference internal" href="#fixed-and-variable-sizes">Fixed and variable sizes</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/news/better_primitive_collections_proposal.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search/" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="better-primitive-collections">
<h1>Better primitive collections<a class="headerlink" href="#better-primitive-collections" title="Permalink to this headline">¶</a></h1>
<p>There are many primitive collections libraries for Java. Uf you are not familiar with them, read
<a class="reference external" href="http://java-performance.info/hashmap-overview-jdk-fastutil-goldman-sachs-hppc-koloboke-trove-january-2015/">this overview</a>
I like them for reduced memory usage and improved performance. Primitive collections are also part of MapDB.</p>
<p>Recently I faced problem which could not be solved by existing library.
There is <a class="reference external" href="https://github.com/conveyal/r5">R5 routing framework</a> developed by Conveyal.
On each startup it loads data into memory, performs calculations and exits.
Data are large, and can not be stored permanently stored in-memory.
Also memory usage is already optimized, so there is no way to improve it.</p>
<p>In this situation primitive collections (Trove in this case) are failing because they do not fit onto memory.
Databases (graph or MapDB) can handle big data, but will fail due to performance overhead.
R5 is quite optimized and regular database has too big latencies and can not compete with <code class="docutils literal"><span class="pre">long[]</span></code> arrays.</p>
<div class="section" id="memory-mapped-files">
<h2>Memory mapped files<a class="headerlink" href="#memory-mapped-files" title="Permalink to this headline">¶</a></h2>
<p>So there is need for new primitive collection. It should store data in-memory,
but also be swappable to disk if free memory runs low. On-heap <code class="docutils literal"><span class="pre">long[]</span></code> is not really swappable,
Garbage Collector might randomly touch an array and load it from swap.
Also data should be persisted between JVM restarts to save import time (without crash protection).
That sounds like a job for memory mapped files.</p>
<p>Bit of theory: Collections such as HashSet&lt;Long&gt; store data in an array: <code class="docutils literal"><span class="pre">Long[]</span></code>.
Primitive collections remove boxing: <code class="docutils literal"><span class="pre">long[]</span></code>.
But one could also use raw binary storage such as <code class="docutils literal"><span class="pre">byte[]</span></code>, <code class="docutils literal"><span class="pre">DirectByteByffer</span></code>,
<code class="docutils literal"><span class="pre">RandomAccessFile</span></code> or <code class="docutils literal"><span class="pre">MappedByteBuffer</span></code>.
Access to <code class="docutils literal"><span class="pre">longs</span></code> will get slightly complicated, but most
storage options provide methods such as <code class="docutils literal"><span class="pre">setLong(index,value)</span></code> or <code class="docutils literal"><span class="pre">getLong(index)</span></code>
and are very similar to arrays.</p>
<p>It seems fairly straightforward, but things get complicated very quickly with resize, initialization, shutdown etc.
From MapDB I have some experience with using alternative storage back-ends (MapDB supports about 10 memory and file backends),
so I will give it a try.</p>
</div>
<div class="section" id="code-generators">
<h2>Code generators<a class="headerlink" href="#code-generators" title="Permalink to this headline">¶</a></h2>
<p>Primitive collections relay on code generators to combine various types together. There are many classes
such as <code class="docutils literal"><span class="pre">IntObjectHashMap&lt;V&gt;</span></code> or <code class="docutils literal"><span class="pre">IntLongHashMap&lt;V&gt;</span></code>. So it should be possible to
modify code generator and add one extra parameters for storage. Than there will be classes such as
<code class="docutils literal"><span class="pre">MmapIntObjectHashMap&lt;V&gt;</span></code> or <code class="docutils literal"><span class="pre">HeapIntLongHashMap&lt;V&gt;</span></code>.</p>
<p>Large number of classes expands Jar files. Koloboke and FastUtil both have binary jar files with 16MB size.
Extra combinations for backend will bring jar file size to around 100MB. I think it is reasonable
to split implementations into several (hundreds?) smaller jar files. MapDB already has scripts to
deploy autogenerated artifacts into Maven repositories.</p>
<p>It is question what primitive collection library should be extended/forked to do this. I am leaning towards
<a class="reference external" href="https://github.com/OpenHFT/Koloboke">Koloboke</a>, because its code is already used in MapDB and
<a class="reference external" href="https://github.com/OpenHFT/Koloboke/wiki/Koloboke:-roll-the-collection-implementation-with-features-you-need">their proposal</a>
is similar to my own plans.</p>
</div>
<div class="section" id="byte-versus-8bit-integer">
<h2>Byte versus 8bit Integer<a class="headerlink" href="#byte-versus-8bit-integer" title="Permalink to this headline">¶</a></h2>
<p>Most primitive collections supports less common primitive types: (boolean, byte, char and float).
I think their only benefit is reduced storage space.
So we can remove of less common primitive types, if bigger types will optionally consume smaller space in storage.
<code class="docutils literal"><span class="pre">CharSet</span></code> has no advantage over <code class="docutils literal"><span class="pre">IntSet</span></code> if integers are only read from 16 bytes.</p>
<p>Also Java8 streams have basic support for primitive collections. There is <code class="docutils literal"><span class="pre">Stream</span></code> class, but also
specialized <code class="docutils literal"><span class="pre">IntStream</span></code>, <code class="docutils literal"><span class="pre">LongStream</span></code> and <code class="docutils literal"><span class="pre">DoubleStream</span></code>. Other primitive types are missing.</p>
<p>So I think it makes a sense to only keep <code class="docutils literal"><span class="pre">int</span></code>, <code class="docutils literal"><span class="pre">long</span></code> and <code class="docutils literal"><span class="pre">double</span></code>. Other primitive types will be removed.</p>
<p>As alternative one will be able to specify how many bites each entry consumes.
So one can have <code class="docutils literal"><span class="pre">LongLongMap</span></code> where key consumes 48 bits and value 56 bits (one case from MapDB).
It will be code generated, so there will be classes such as <code class="docutils literal"><span class="pre">Long6Long7HashMap</span></code>.</p>
</div>
<div class="section" id="bit-support">
<h2>64bit support<a class="headerlink" href="#bit-support" title="Permalink to this headline">¶</a></h2>
<p>Java is 32bit by design: <code class="docutils literal"><span class="pre">Object.hashCode()</span></code>, maximal array size, <code class="docutils literal"><span class="pre">List.get(int)</span></code>, <code class="docutils literal"><span class="pre">ByteBuffer</span></code> addressing,
<code class="docutils literal"><span class="pre">Collection.size()</span></code> etc..
I find it quite frustrating, so this collection framework should offer both 32bit and 64bit options.
It should support 64bit hashCode, maximal sizes,  List getters and so on. Some
collections in memory-mapped files could easily have terabytes of data and 10^12 elements (real case from MapDB).</p>
</div>
<div class="section" id="data-corruption">
<h2>Data corruption<a class="headerlink" href="#data-corruption" title="Permalink to this headline">¶</a></h2>
<p>If collection contains gigabytes (or terrabytes) of data, it probably took very long time to create.
So there should be some sort of persistence between JVM restarts.
It is already done if collection is stored in memory mapped file.</p>
<p>Working on MapDB taught me that there must be at least some protection in
case JVM crashed and file become corrupted.
Corrupted files could introduce all sort of false alarms and strange bugs.</p>
<p>So this library will have two options to detect data corruption. First option is file seal based on timestamp.
It detects if file was closed correctly or JVM somehow crashed before closing it.
It is good enough for most cases and has almost no overhead.</p>
<p>Another option to detect file corruption is file checksum. That requires file traversal and checksum calculation
every time file is opened or closed.</p>
</div>
<div class="section" id="object-serialization">
<h2>Object serialization<a class="headerlink" href="#object-serialization" title="Permalink to this headline">¶</a></h2>
<p>Data are stored in binary form. MapDB has fast and space efficient serialization framework,
that will be used for non-primitive data. Performance overhead of deserialization in MapDB is around 20%.</p>
<p>For better performance there will be an option to skip serialization, and use data in serialized form.
In this case operations such as Map.get() return only file offset and user will use library such as
Protobuf or Thrift to interpret binary data.</p>
</div>
<div class="section" id="fixed-and-variable-sizes">
<h2>Fixed and variable sizes<a class="headerlink" href="#fixed-and-variable-sizes" title="Permalink to this headline">¶</a></h2>
<p>Array like structures can only work with fixed size records.
For variable sized records collection can use <code class="docutils literal"><span class="pre">StoreDirect</span></code> class from MapDB.
It operates over mmap file and provides space allocator, compaction, free space reuse etc..</p>
<p>Collection such as <code class="docutils literal"><span class="pre">HashMap&lt;long,Object&gt;</span></code> would combine two files: an array of longs for hash table, and second file
for values which managed by <code class="docutils literal"><span class="pre">StoreDirect</span></code>.</p>
</div>
</div>

  <div class="section">
  
    


<div class="section">
  <span style="float: left;">
  
  Previous: 
  <a href="../../changelog-archive/#beta11-released-2015-11-18">
    
    2.0-beta11 released (2015-11-18)
  </a>
  
  </span>
  <span>&nbsp;</span>
  <span style="float: right;">
  
  Next: 
  <a href="../../changelog-archive/#beta12-released-2015-11-26">
    2.0-beta12 released (2015-11-26)
    
  </a>
  </span>
  
</div>

  
  
    <div class="section">
    <h2>Comments</h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'mapdb';
        var disqus_identifier = '/news/better_primitive_collections_proposal/';
        var disqus_title = 'Better primitive collections';
        var disqus_url = 'http://www.mapdb.org/news/better_primitive_collections_proposal';

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  
  </div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li><a href="../../">Home</a>&nbsp;|</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, jan.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>